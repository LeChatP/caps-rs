/*!
A pure-Rust library to work with Linux capabilities.

It provides support for manipulating capabilities available on modern Linux
kernels. It supports traditional POSIX sets (Effective, Inheritable, Permitted)
as well as Linux-specific Ambient and Bounding capabilities sets.

```rust
type ExResult<T> = Result<T, Box<dyn std::error::Error + 'static>>;

fn manipulate_caps() -> ExResult<()> {
    use caps::CapSet;
    use caps::capability::Capability;

    if caps::has_cap(None, CapSet::Permitted, &Capability::CAP_SYS_NICE)? {
        caps::drop(None, CapSet::Effective, Capability::CAP_SYS_NICE)?;
        let effective = caps::read(None, CapSet::Effective)?;
        assert_eq!(effective.contains(&Capability::CAP_SYS_NICE), false);

        caps::clear(None, CapSet::Effective)?;
        let cleared = caps::read(None, CapSet::Effective)?;
        assert_eq!(cleared.is_empty(), true);
    };

    Ok(())
}
```
!*/

pub mod errors;
pub mod runtime;
pub mod securebits;

// All autogenerated capabilities definitions.
pub mod capability;

// Implementation of Bounding set.
mod ambient;
// Implementation of POSIX sets.
mod base;
// Implementation of Bounding set.
mod bounding;
// All kernel related constants.
mod nr;

use std::{iter::FromIterator, ops::BitXor};

use crate::errors::CapsError;
use capability::Capability;



/// Linux capabilities sets.
///
/// All capabilities sets supported by Linux, including standard
/// POSIX and custom ones. See `capabilities(7)`.
#[derive(Debug, Clone, Copy)]
pub enum CapSet {
    /// Ambient capabilities set (from Linux 4.3).
    Ambient,
    /// Bounding capabilities set (from Linux 2.6.25)
    Bounding,
    /// Effective capabilities set (from POSIX)
    Effective,
    /// Inheritable capabilities set (from POSIX)
    Inheritable,
    /// Permitted capabilities set (from POSIX)
    Permitted,
}

impl Capability {
    /// Returns the bitmask corresponding to this capability value.
    #[allow(clippy::trivially_copy_pass_by_ref)]
    pub fn bitmask(&self) -> usize {
        1usize << (*self as u8)
    }

    /// Returns the index of this capability, i.e. its kernel-defined value.
    #[allow(clippy::trivially_copy_pass_by_ref)]
    pub fn index(&self) -> u8 {
        *self as u8
    }
}

#[deprecated(note = "use `Capabilities` instead")]
pub type CapsHashSet = std::collections::HashSet<Capability>;

/// An `HashSet` specialized on `Capability`.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Capabilities {
    caps: usize,
}

/// An iterator over the capabilities in a `Capabilities` set.
pub struct CapabilitiesIter {
    caps: usize,
    index: u8,
}

impl Iterator for CapabilitiesIter {
    type Item = Capability;

    fn next(&mut self) -> Option<Self::Item> {
        while (self.index as usize) < Capability::__Nonexhaustive.index().into() {
            let cap = Capability::from(self.index);
            self.index += 1;
            if self.caps & cap.bitmask() != 0 {
                return Some(cap);
            }
        }
        None
    }
}

impl Capabilities {
    /// Create a new empty `Capabilities`.
    pub fn new() -> Self {
        Self { caps: 0 }
    }

    pub fn all() -> Self {
        Self {
            caps: !0 & Capability::__Nonexhaustive.bitmask() - 1,
        }
    }

    pub fn len(&self) -> usize {
        self.iter().count()
    }

    /// Add a capability to the set.
    pub fn insert(&mut self, cap: &Capability) -> bool {
        let old = self.caps;
        self.caps |= cap.bitmask();
        old != self.caps
    }

    /// Remove a capability from the set.
    pub fn remove(&mut self, cap: &Capability) -> bool {
        let old = self.caps;
        self.caps &= !cap.bitmask();
        old != self.caps
    }

    /// Check if a capability is in the set.
    pub fn contains(&self, cap: &Capability) -> bool {
        self.caps & cap.bitmask() != 0
    }

    /// Return an iterator over the capabilities in the set.
    pub fn iter(&self) -> CapabilitiesIter {
        CapabilitiesIter {
            caps: self.caps,
            index: 0,
        }
    }

    pub fn symmetric_difference(&self, other: &Capabilities) -> Capabilities {
        Capabilities {
            caps: self.caps.bitxor(other.caps),
        }
    }

    pub fn difference(&self, other: &Capabilities) -> Capabilities {
        Capabilities {
            caps: self.caps & !other.caps,
        }
    }

    pub fn intersection(&self, other: &Capabilities) -> Capabilities {
        Capabilities {
            caps: self.caps & other.caps,
        }
    }

    pub fn union(&self, other: &Capabilities) -> Capabilities {
        Capabilities {
            caps: self.caps | other.caps,
        }
    }

    pub fn is_empty(&self) -> bool {
        self.caps == 0
    }

    pub fn clear(&mut self) {
        self.caps = 0;
    }
}

impl std::fmt::Display for Capabilities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut first = true;
        for cap in self.iter() {
            if first {
                first = false;
            } else {
                write!(f, ",")?;
            }
            write!(f, "{}", cap)?;
        }
        Ok(())
    }
}

impl std::str::FromStr for Capabilities {
    type Err = CapsError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut caps = Capabilities::new();
        for cap in s.split(',') {
            caps.insert(&Capability::from_str(cap)?);
        }
        Ok(caps)
    }
}

impl IntoIterator for Capabilities {
    type Item = Capability;
    type IntoIter = CapabilitiesIter;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}


/// Check if a thread contains a capability in a set.
///
/// Check if set `cset` for thread `tid` contains capability `cap`.
/// If `tid` is `None`, this operates on current thread (tid=0).
/// It cannot check Ambient or Bounding capabilities of other processes.
pub fn has_cap(tid: Option<i32>, cset: CapSet, cap: &Capability) -> Result<bool, CapsError> {
    let t = tid.unwrap_or(0);
    match cset {
        CapSet::Ambient if t == 0 => ambient::has_cap(cap),
        CapSet::Bounding if t == 0 => bounding::has_cap(cap),
        CapSet::Effective | CapSet::Inheritable | CapSet::Permitted => base::has_cap(t, cset, &cap),
        _ => Err("operation not supported".into()),
    }
}

/// Return all capabilities in a set for a thread.
///
/// Return current content of set `cset` for thread `tid`.
/// If `tid` is `None`, this operates on current thread (tid=0).
/// It cannot read Ambient or Bounding capabilities of other processes.
pub fn read(tid: Option<i32>, cset: CapSet) -> Result<Capabilities, CapsError> {
    let t = tid.unwrap_or(0);
    match cset {
        CapSet::Ambient if t == 0 => ambient::read(),
        CapSet::Bounding if t == 0 => bounding::read(),
        CapSet::Effective | CapSet::Inheritable | CapSet::Permitted => base::read(t, cset),
        _ => Err("operation not supported".into()),
    }
}

/// Set a capability set for a thread to a new value.
///
/// All and only capabilities in `value` will be set for set `cset` for thread `tid`.
/// If `tid` is `None`, this operates on current thread (tid=0).
/// It cannot manipulate Ambient set of other processes.
/// Capabilities cannot be set in Bounding set.
pub fn set(tid: Option<i32>, cset: CapSet, value: &Capabilities) -> Result<(), CapsError> {
    let t = tid.unwrap_or(0);
    match cset {
        CapSet::Ambient if t == 0 => ambient::set(value),
        CapSet::Effective | CapSet::Inheritable | CapSet::Permitted => base::set(t, cset, value),
        _ => Err("operation not supported".into()),
    }
}

/// Clear all capabilities in a set for a thread.
///
/// All capabilities will be cleared from set `cset` for thread `tid`.
/// If `tid` is `None`, this operates on current thread (tid=0).
/// It cannot manipulate Ambient or Bounding set of other processes.
pub fn clear(tid: Option<i32>, cset: CapSet) -> Result<(), CapsError> {
    let t = tid.unwrap_or(0);
    match cset {
        CapSet::Ambient if t == 0 => ambient::clear(),
        CapSet::Bounding if t == 0 => bounding::clear(),
        CapSet::Effective | CapSet::Permitted | CapSet::Inheritable => base::clear(t, cset),
        _ => Err("operation not supported".into()),
    }
}

/// Raise a single capability in a set for a thread.
///
/// Capabilities `cap` will be raised from set `cset` of thread `tid`.
/// If `tid` is `None`, this operates on current thread (tid=0).
/// It cannot manipulate Ambient set of other processes.
/// Capabilities cannot be raised in Bounding set.
pub fn raise(tid: Option<i32>, cset: CapSet, cap: Capability) -> Result<(), CapsError> {
    let t = tid.unwrap_or(0);
    match cset {
        CapSet::Ambient if t == 0 => ambient::raise(&cap),
        CapSet::Effective | CapSet::Permitted | CapSet::Inheritable => base::raise(t, cset, &cap),
        _ => Err("operation not supported".into()),
    }
}

/// Drop a single capability from a set for a thread.
///
/// Capabilities `cap` will be dropped from set `cset` of thread `tid`.
/// If `tid` is `None`, this operates on current thread (tid=0).
/// It cannot manipulate Ambient and Bounding sets of other processes.
pub fn drop(tid: Option<i32>, cset: CapSet, cap: Capability) -> Result<(), CapsError> {
    let t = tid.unwrap_or(0);
    match cset {
        CapSet::Ambient if t == 0 => ambient::drop(&cap),
        CapSet::Bounding if t == 0 => bounding::drop(&cap),
        CapSet::Effective | CapSet::Permitted | CapSet::Inheritable => base::drop(t, cset, &cap),
        _ => Err("operation not supported".into()),
    }
}

/// Return the set of all capabilities supported by this library.
#[deprecated(note = "use `Capabilities::all()` instead")]
pub fn all() -> CapsHashSet {
    let slice = vec![
        Capability::CAP_CHOWN,
        Capability::CAP_DAC_OVERRIDE,
        Capability::CAP_DAC_READ_SEARCH,
        Capability::CAP_FOWNER,
        Capability::CAP_FSETID,
        Capability::CAP_KILL,
        Capability::CAP_SETGID,
        Capability::CAP_SETUID,
        Capability::CAP_SETPCAP,
        Capability::CAP_LINUX_IMMUTABLE,
        Capability::CAP_NET_BIND_SERVICE,
        Capability::CAP_NET_BROADCAST,
        Capability::CAP_NET_ADMIN,
        Capability::CAP_NET_RAW,
        Capability::CAP_IPC_LOCK,
        Capability::CAP_IPC_OWNER,
        Capability::CAP_SYS_MODULE,
        Capability::CAP_SYS_RAWIO,
        Capability::CAP_SYS_CHROOT,
        Capability::CAP_SYS_PTRACE,
        Capability::CAP_SYS_PACCT,
        Capability::CAP_SYS_ADMIN,
        Capability::CAP_SYS_BOOT,
        Capability::CAP_SYS_NICE,
        Capability::CAP_SYS_RESOURCE,
        Capability::CAP_SYS_TIME,
        Capability::CAP_SYS_TTY_CONFIG,
        Capability::CAP_MKNOD,
        Capability::CAP_LEASE,
        Capability::CAP_AUDIT_WRITE,
        Capability::CAP_AUDIT_CONTROL,
        Capability::CAP_SETFCAP,
        Capability::CAP_MAC_OVERRIDE,
        Capability::CAP_MAC_ADMIN,
        Capability::CAP_SYSLOG,
        Capability::CAP_WAKE_ALARM,
        Capability::CAP_BLOCK_SUSPEND,
        Capability::CAP_AUDIT_READ,
        Capability::CAP_PERFMON,
        Capability::CAP_BPF,
        Capability::CAP_CHECKPOINT_RESTORE,
    ];
    CapsHashSet::from_iter(slice)
}

/// Convert an informal capability name into a canonical form.
///
/// This converts the input string to uppercase and ensures that it starts with
/// `CAP_`, prepending it if necessary. It performs no validity checks so the
/// output may not represent an actual capability. To check if it is, pass it
/// to [`from_str`].
///
/// [`from_str`]: enum.Capability.html#method.from_str
pub fn to_canonical(name: &str) -> String {
    let uppername = name.to_uppercase();
    if uppername.starts_with("CAP_") {
        uppername
    } else {
        ["CAP_", &uppername].concat()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;

    #[test]
    fn test_all_roundtrip() {
        let all = all();
        assert!(all.len() > 0);
        for c in all {
            let name = c.to_string();
            let parsed: Capability = name.parse().unwrap();
            assert_eq!(c, parsed);
        }
    }

    #[test]
    fn test_parse_invalid() {
        let p1 = Capability::from_str("CAP_FOO");
        let p1_err = p1.unwrap_err();
        assert!(p1_err.to_string().contains("invalid"));
        assert!(format!("{}", p1_err).contains("CAP_FOO"));
        let p2: Result<Capability, CapsError> = "CAP_BAR".parse();
        assert!(p2.is_err());
    }

    #[test]
    fn test_to_canonical() {
        let p1 = "foo";
        assert!(Capability::from_str(&to_canonical(p1)).is_err());
        let p2 = "sys_admin";
        assert!(Capability::from_str(&to_canonical(p2)).is_ok());
        let p3 = capability::S_CAP_SYS_CHROOT;
        assert!(Capability::from_str(&to_canonical(p3)).is_ok());
    }

    #[test]
    fn test_capabilities_all_roundtrip(){
        let all = Capabilities::all();
        assert!(all.len() > 0);
        for c in all {
            let name = c.to_string();
            let parsed: Capability = name.parse().unwrap();
            assert_eq!(c, parsed);
        }
    }

    #[test]
    fn test_capabilities_str() {
        let p1 = Capabilities::from_str(capability::S_CAP_CHOWN).unwrap();
        assert!(p1.contains(&Capability::CAP_CHOWN));
    }

    #[test]
    #[cfg(feature = "serde_support")]
    fn test_serde() {
        let p1 = Capability::from_str(capability::S_CAP_CHOWN).unwrap();
        let ser = serde_json::to_value(&p1).unwrap();
        let deser: Capability = serde_json::from_value(ser).unwrap();
        assert_eq!(deser, p1);
    }
}
