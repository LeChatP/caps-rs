// This file is generated by build.rs
// Do not edit this file directly
// Instead edit build.rs and run cargo build
/* Capabilities Values from capability.h kernel source code */
pub const S_CAP_CHOWN: &str = "CAP_CHOWN";
pub const S_CAP_DAC_OVERRIDE: &str = "CAP_DAC_OVERRIDE";
pub const S_CAP_DAC_READ_SEARCH: &str = "CAP_DAC_READ_SEARCH";
pub const S_CAP_FOWNER: &str = "CAP_FOWNER";
pub const S_CAP_FSETID: &str = "CAP_FSETID";
pub const S_CAP_KILL: &str = "CAP_KILL";
pub const S_CAP_SETGID: &str = "CAP_SETGID";
pub const S_CAP_SETUID: &str = "CAP_SETUID";
pub const S_CAP_SETPCAP: &str = "CAP_SETPCAP";
pub const S_CAP_LINUX_IMMUTABLE: &str = "CAP_LINUX_IMMUTABLE";
pub const S_CAP_NET_BIND_SERVICE: &str = "CAP_NET_BIND_SERVICE";
pub const S_CAP_NET_BROADCAST: &str = "CAP_NET_BROADCAST";
pub const S_CAP_NET_ADMIN: &str = "CAP_NET_ADMIN";
pub const S_CAP_NET_RAW: &str = "CAP_NET_RAW";
pub const S_CAP_IPC_LOCK: &str = "CAP_IPC_LOCK";
pub const S_CAP_IPC_OWNER: &str = "CAP_IPC_OWNER";
pub const S_CAP_SYS_MODULE: &str = "CAP_SYS_MODULE";
pub const S_CAP_SYS_RAWIO: &str = "CAP_SYS_RAWIO";
pub const S_CAP_SYS_CHROOT: &str = "CAP_SYS_CHROOT";
pub const S_CAP_SYS_PTRACE: &str = "CAP_SYS_PTRACE";
pub const S_CAP_SYS_PACCT: &str = "CAP_SYS_PACCT";
pub const S_CAP_SYS_ADMIN: &str = "CAP_SYS_ADMIN";
pub const S_CAP_SYS_BOOT: &str = "CAP_SYS_BOOT";
pub const S_CAP_SYS_NICE: &str = "CAP_SYS_NICE";
pub const S_CAP_SYS_RESOURCE: &str = "CAP_SYS_RESOURCE";
pub const S_CAP_SYS_TIME: &str = "CAP_SYS_TIME";
pub const S_CAP_SYS_TTY_CONFIG: &str = "CAP_SYS_TTY_CONFIG";
pub const S_CAP_MKNOD: &str = "CAP_MKNOD";
pub const S_CAP_LEASE: &str = "CAP_LEASE";
pub const S_CAP_AUDIT_WRITE: &str = "CAP_AUDIT_WRITE";
pub const S_CAP_AUDIT_CONTROL: &str = "CAP_AUDIT_CONTROL";
pub const S_CAP_SETFCAP: &str = "CAP_SETFCAP";
pub const S_CAP_MAC_OVERRIDE: &str = "CAP_MAC_OVERRIDE";
pub const S_CAP_MAC_ADMIN: &str = "CAP_MAC_ADMIN";
pub const S_CAP_SYSLOG: &str = "CAP_SYSLOG";
pub const S_CAP_WAKE_ALARM: &str = "CAP_WAKE_ALARM";
pub const S_CAP_BLOCK_SUSPEND: &str = "CAP_BLOCK_SUSPEND";
pub const S_CAP_AUDIT_READ: &str = "CAP_AUDIT_READ";
pub const S_CAP_PERFMON: &str = "CAP_PERFMON";
pub const S_CAP_BPF: &str = "CAP_BPF";
pub const S_CAP_CHECKPOINT_RESTORE: &str = "CAP_CHECKPOINT_RESTORE";
/// Linux capabilities.
///
/// All capabilities supported by Linux, including standard
/// POSIX and custom ones. See `capabilities(7)`.
#[allow(clippy::manual_non_exhaustive)]
#[allow(non_camel_case_types)]
#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]
#[repr(u8)]
#[cfg_attr(
    feature = "serde_support",
    derive(serde::Serialize, serde::Deserialize)
)]
pub enum Capability {
    CAP_CHOWN = 0,
    CAP_DAC_OVERRIDE = 1,
    CAP_DAC_READ_SEARCH = 2,
    CAP_FOWNER = 3,
    CAP_FSETID = 4,
    CAP_KILL = 5,
    CAP_SETGID = 6,
    CAP_SETUID = 7,
    CAP_SETPCAP = 8,
    CAP_LINUX_IMMUTABLE = 9,
    CAP_NET_BIND_SERVICE = 10,
    CAP_NET_BROADCAST = 11,
    CAP_NET_ADMIN = 12,
    CAP_NET_RAW = 13,
    CAP_IPC_LOCK = 14,
    CAP_IPC_OWNER = 15,
    CAP_SYS_MODULE = 16,
    CAP_SYS_RAWIO = 17,
    CAP_SYS_CHROOT = 18,
    CAP_SYS_PTRACE = 19,
    CAP_SYS_PACCT = 20,
    CAP_SYS_ADMIN = 21,
    CAP_SYS_BOOT = 22,
    CAP_SYS_NICE = 23,
    CAP_SYS_RESOURCE = 24,
    CAP_SYS_TIME = 25,
    CAP_SYS_TTY_CONFIG = 26,
    CAP_MKNOD = 27,
    CAP_LEASE = 28,
    CAP_AUDIT_WRITE = 29,
    CAP_AUDIT_CONTROL = 30,
    CAP_SETFCAP = 31,
    CAP_MAC_OVERRIDE = 32,
    CAP_MAC_ADMIN = 33,
    CAP_SYSLOG = 34,
    CAP_WAKE_ALARM = 35,
    CAP_BLOCK_SUSPEND = 36,
    CAP_AUDIT_READ = 37,
    CAP_PERFMON = 38,
    CAP_BPF = 39,
    CAP_CHECKPOINT_RESTORE = 40,
    #[doc(hidden)]
    __Nonexhaustive,
}

impl std::str::FromStr for Capability {
    type Err = crate::errors::CapsError;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            S_CAP_CHOWN => Ok(Capability::CAP_CHOWN),
            S_CAP_DAC_OVERRIDE => Ok(Capability::CAP_DAC_OVERRIDE),
            S_CAP_DAC_READ_SEARCH => Ok(Capability::CAP_DAC_READ_SEARCH),
            S_CAP_FOWNER => Ok(Capability::CAP_FOWNER),
            S_CAP_FSETID => Ok(Capability::CAP_FSETID),
            S_CAP_KILL => Ok(Capability::CAP_KILL),
            S_CAP_SETGID => Ok(Capability::CAP_SETGID),
            S_CAP_SETUID => Ok(Capability::CAP_SETUID),
            S_CAP_SETPCAP => Ok(Capability::CAP_SETPCAP),
            S_CAP_LINUX_IMMUTABLE => Ok(Capability::CAP_LINUX_IMMUTABLE),
            S_CAP_NET_BIND_SERVICE => Ok(Capability::CAP_NET_BIND_SERVICE),
            S_CAP_NET_BROADCAST => Ok(Capability::CAP_NET_BROADCAST),
            S_CAP_NET_ADMIN => Ok(Capability::CAP_NET_ADMIN),
            S_CAP_NET_RAW => Ok(Capability::CAP_NET_RAW),
            S_CAP_IPC_LOCK => Ok(Capability::CAP_IPC_LOCK),
            S_CAP_IPC_OWNER => Ok(Capability::CAP_IPC_OWNER),
            S_CAP_SYS_MODULE => Ok(Capability::CAP_SYS_MODULE),
            S_CAP_SYS_RAWIO => Ok(Capability::CAP_SYS_RAWIO),
            S_CAP_SYS_CHROOT => Ok(Capability::CAP_SYS_CHROOT),
            S_CAP_SYS_PTRACE => Ok(Capability::CAP_SYS_PTRACE),
            S_CAP_SYS_PACCT => Ok(Capability::CAP_SYS_PACCT),
            S_CAP_SYS_ADMIN => Ok(Capability::CAP_SYS_ADMIN),
            S_CAP_SYS_BOOT => Ok(Capability::CAP_SYS_BOOT),
            S_CAP_SYS_NICE => Ok(Capability::CAP_SYS_NICE),
            S_CAP_SYS_RESOURCE => Ok(Capability::CAP_SYS_RESOURCE),
            S_CAP_SYS_TIME => Ok(Capability::CAP_SYS_TIME),
            S_CAP_SYS_TTY_CONFIG => Ok(Capability::CAP_SYS_TTY_CONFIG),
            S_CAP_MKNOD => Ok(Capability::CAP_MKNOD),
            S_CAP_LEASE => Ok(Capability::CAP_LEASE),
            S_CAP_AUDIT_WRITE => Ok(Capability::CAP_AUDIT_WRITE),
            S_CAP_AUDIT_CONTROL => Ok(Capability::CAP_AUDIT_CONTROL),
            S_CAP_SETFCAP => Ok(Capability::CAP_SETFCAP),
            S_CAP_MAC_OVERRIDE => Ok(Capability::CAP_MAC_OVERRIDE),
            S_CAP_MAC_ADMIN => Ok(Capability::CAP_MAC_ADMIN),
            S_CAP_SYSLOG => Ok(Capability::CAP_SYSLOG),
            S_CAP_WAKE_ALARM => Ok(Capability::CAP_WAKE_ALARM),
            S_CAP_BLOCK_SUSPEND => Ok(Capability::CAP_BLOCK_SUSPEND),
            S_CAP_AUDIT_READ => Ok(Capability::CAP_AUDIT_READ),
            S_CAP_PERFMON => Ok(Capability::CAP_PERFMON),
            S_CAP_BPF => Ok(Capability::CAP_BPF),
            S_CAP_CHECKPOINT_RESTORE => Ok(Capability::CAP_CHECKPOINT_RESTORE),
            _ => Err(format!("invalid capability: {}", s).into()),
        }
    }
}
impl From<u8> for Capability {
    fn from(value: u8) -> Self {
        match value {
            0 => Capability::CAP_CHOWN,
            1 => Capability::CAP_DAC_OVERRIDE,
            2 => Capability::CAP_DAC_READ_SEARCH,
            3 => Capability::CAP_FOWNER,
            4 => Capability::CAP_FSETID,
            5 => Capability::CAP_KILL,
            6 => Capability::CAP_SETGID,
            7 => Capability::CAP_SETUID,
            8 => Capability::CAP_SETPCAP,
            9 => Capability::CAP_LINUX_IMMUTABLE,
            10 => Capability::CAP_NET_BIND_SERVICE,
            11 => Capability::CAP_NET_BROADCAST,
            12 => Capability::CAP_NET_ADMIN,
            13 => Capability::CAP_NET_RAW,
            14 => Capability::CAP_IPC_LOCK,
            15 => Capability::CAP_IPC_OWNER,
            16 => Capability::CAP_SYS_MODULE,
            17 => Capability::CAP_SYS_RAWIO,
            18 => Capability::CAP_SYS_CHROOT,
            19 => Capability::CAP_SYS_PTRACE,
            20 => Capability::CAP_SYS_PACCT,
            21 => Capability::CAP_SYS_ADMIN,
            22 => Capability::CAP_SYS_BOOT,
            23 => Capability::CAP_SYS_NICE,
            24 => Capability::CAP_SYS_RESOURCE,
            25 => Capability::CAP_SYS_TIME,
            26 => Capability::CAP_SYS_TTY_CONFIG,
            27 => Capability::CAP_MKNOD,
            28 => Capability::CAP_LEASE,
            29 => Capability::CAP_AUDIT_WRITE,
            30 => Capability::CAP_AUDIT_CONTROL,
            31 => Capability::CAP_SETFCAP,
            32 => Capability::CAP_MAC_OVERRIDE,
            33 => Capability::CAP_MAC_ADMIN,
            34 => Capability::CAP_SYSLOG,
            35 => Capability::CAP_WAKE_ALARM,
            36 => Capability::CAP_BLOCK_SUSPEND,
            37 => Capability::CAP_AUDIT_READ,
            38 => Capability::CAP_PERFMON,
            39 => Capability::CAP_BPF,
            40 => Capability::CAP_CHECKPOINT_RESTORE,
            _ => unreachable!("invalid capability"),
        }
    }
}
impl std::fmt::Display for Capability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Capability::CAP_CHOWN => S_CAP_CHOWN,
                Capability::CAP_DAC_OVERRIDE => S_CAP_DAC_OVERRIDE,
                Capability::CAP_DAC_READ_SEARCH => S_CAP_DAC_READ_SEARCH,
                Capability::CAP_FOWNER => S_CAP_FOWNER,
                Capability::CAP_FSETID => S_CAP_FSETID,
                Capability::CAP_KILL => S_CAP_KILL,
                Capability::CAP_SETGID => S_CAP_SETGID,
                Capability::CAP_SETUID => S_CAP_SETUID,
                Capability::CAP_SETPCAP => S_CAP_SETPCAP,
                Capability::CAP_LINUX_IMMUTABLE => S_CAP_LINUX_IMMUTABLE,
                Capability::CAP_NET_BIND_SERVICE => S_CAP_NET_BIND_SERVICE,
                Capability::CAP_NET_BROADCAST => S_CAP_NET_BROADCAST,
                Capability::CAP_NET_ADMIN => S_CAP_NET_ADMIN,
                Capability::CAP_NET_RAW => S_CAP_NET_RAW,
                Capability::CAP_IPC_LOCK => S_CAP_IPC_LOCK,
                Capability::CAP_IPC_OWNER => S_CAP_IPC_OWNER,
                Capability::CAP_SYS_MODULE => S_CAP_SYS_MODULE,
                Capability::CAP_SYS_RAWIO => S_CAP_SYS_RAWIO,
                Capability::CAP_SYS_CHROOT => S_CAP_SYS_CHROOT,
                Capability::CAP_SYS_PTRACE => S_CAP_SYS_PTRACE,
                Capability::CAP_SYS_PACCT => S_CAP_SYS_PACCT,
                Capability::CAP_SYS_ADMIN => S_CAP_SYS_ADMIN,
                Capability::CAP_SYS_BOOT => S_CAP_SYS_BOOT,
                Capability::CAP_SYS_NICE => S_CAP_SYS_NICE,
                Capability::CAP_SYS_RESOURCE => S_CAP_SYS_RESOURCE,
                Capability::CAP_SYS_TIME => S_CAP_SYS_TIME,
                Capability::CAP_SYS_TTY_CONFIG => S_CAP_SYS_TTY_CONFIG,
                Capability::CAP_MKNOD => S_CAP_MKNOD,
                Capability::CAP_LEASE => S_CAP_LEASE,
                Capability::CAP_AUDIT_WRITE => S_CAP_AUDIT_WRITE,
                Capability::CAP_AUDIT_CONTROL => S_CAP_AUDIT_CONTROL,
                Capability::CAP_SETFCAP => S_CAP_SETFCAP,
                Capability::CAP_MAC_OVERRIDE => S_CAP_MAC_OVERRIDE,
                Capability::CAP_MAC_ADMIN => S_CAP_MAC_ADMIN,
                Capability::CAP_SYSLOG => S_CAP_SYSLOG,
                Capability::CAP_WAKE_ALARM => S_CAP_WAKE_ALARM,
                Capability::CAP_BLOCK_SUSPEND => S_CAP_BLOCK_SUSPEND,
                Capability::CAP_AUDIT_READ => S_CAP_AUDIT_READ,
                Capability::CAP_PERFMON => S_CAP_PERFMON,
                Capability::CAP_BPF => S_CAP_BPF,
                Capability::CAP_CHECKPOINT_RESTORE => S_CAP_CHECKPOINT_RESTORE,
                Capability::__Nonexhaustive => unreachable!("invalid capability"),
            }
        )
    }
}
/* Capabilities Documentation from man-pages */
pub fn get_capability_description(cap: Capability) -> &'static str {
    match cap {
        Capability::CAP_AUDIT_CONTROL => {
            r#"(since Linux 2.6.11)
 Enable and disable kernel auditing; change auditing filter rules; retrieve auditing status and filtering
 rules."#
        }
        Capability::CAP_AUDIT_READ => {
            r#"(since Linux 3.16)
 Allow reading the audit log via a multicast netlink socket."#
        }
        Capability::CAP_AUDIT_WRITE => {
            r#"(since Linux 2.6.11)
 Write records to kernel auditing log."#
        }
        Capability::CAP_BLOCK_SUSPEND => {
            r#"(since Linux 3.5)
 Employ features that can block system suspend (epoll(7) EPOLLWAKEUP, /proc/sys/wake_lock)."#
        }
        Capability::CAP_BPF => {
            r#"(since Linux 5.8)
 Employ privileged BPF operations; see bpf(2) and bpf-helpers(7).

 This capability was added in Linux 5.8 to separate out BPF functionality from the overloaded
 CAP_SYS_ADMIN capability."#
        }
        Capability::CAP_CHECKPOINT_RESTORE => {
            r#"(since Linux 5.9)
 • Update /proc/sys/kernel/ns_last_pid (see pid_namespaces(7));
 • employ the set_tid feature of clone3(2);
 • read the contents of the symbolic links in /proc/pid/map_files for other processes.

 This capability was added in Linux 5.9 to separate out checkpoint/restore functionality from the
 overloaded CAP_SYS_ADMIN capability."#
        }
        Capability::CAP_CHOWN => r#"Make arbitrary changes to file UIDs and GIDs (see chown(2))."#,
        Capability::CAP_DAC_OVERRIDE => {
            r#"Bypass file read, write, and execute permission checks. (DAC is an abbreviation of "discretionary
 access control".)"#
        }
        Capability::CAP_DAC_READ_SEARCH => {
            r#"• Bypass file read permission checks and directory read and execute permission checks;
 • invoke open_by_handle_at(2);
 • use the linkat(2) AT_EMPTY_PATH flag to create a link to a file referred to by a file descriptor."#
        }
        Capability::CAP_FOWNER => {
            r#"• Bypass permission checks on operations that normally require the filesystem UID of the process to
 match the UID of the file (e.g., chmod(2), utime(2)), excluding those operations covered by
 CAP_DAC_OVERRIDE and CAP_DAC_READ_SEARCH;
 • set inode flags (see ioctl_iflags(2)) on arbitrary files;
 • set Access Control Lists (ACLs) on arbitrary files;
 • ignore directory sticky bit on file deletion;
 • modify user extended attributes on sticky directory owned by any user;
 • specify O_NOATIME for arbitrary files in open(2) and fcntl(2)."#
        }
        Capability::CAP_FSETID => {
            r#"• Don't clear set-user-ID and set-group-ID mode bits when a file is modified;
 • set the set-group-ID bit for a file whose GID does not match the filesystem or any of the
 supplementary GIDs of the calling process."#
        }
        Capability::CAP_IPC_LOCK => {
            r#"• Lock memory (mlock(2), mlockall(2), mmap(2), shmctl(2));
 • Allocate memory using huge pages (memfd_create(2), mmap(2), shmctl(2))."#
        }
        Capability::CAP_IPC_OWNER => {
            r#"Bypass permission checks for operations on System V IPC objects."#
        }
        Capability::CAP_KILL => {
            r#"Bypass permission checks for sending signals (see kill(2)). This includes use of the ioctl(2)
 KDSIGACCEPT operation."#
        }
        Capability::CAP_LEASE => {
            r#"(since Linux 2.4)
 Establish leases on arbitrary files (see fcntl(2))."#
        }
        Capability::CAP_LINUX_IMMUTABLE => {
            r#"Set the FS_APPEND_FL and FS_IMMUTABLE_FL inode flags (see ioctl_iflags(2))."#
        }
        Capability::CAP_MAC_ADMIN => {
            r#"(since Linux 2.6.25)
 Allow MAC configuration or state changes. Implemented for the Smack Linux Security Module (LSM)."#
        }
        Capability::CAP_MAC_OVERRIDE => {
            r#"(since Linux 2.6.25)
 Override Mandatory Access Control (MAC). Implemented for the Smack LSM."#
        }
        Capability::CAP_MKNOD => {
            r#"(since Linux 2.4)
 Create special files using mknod(2)."#
        }
        Capability::CAP_NET_ADMIN => {
            r#"Perform various network-related operations:
 • interface configuration;
 • administration of IP firewall, masquerading, and accounting;
 • modify routing tables;
 • bind to any address for transparent proxying;
 • set type-of-service (TOS);
 • clear driver statistics;
 • set promiscuous mode;
 • enabling multicasting;
 • use setsockopt(2) to set the following socket options: SO_DEBUG, SO_MARK, SO_PRIORITY (for a priority
 outside the range 0 to 6), SO_RCVBUFFORCE, and SO_SNDBUFFORCE."#
        }
        Capability::CAP_NET_BIND_SERVICE => {
            r#"Bind a socket to Internet domain privileged ports (port numbers less than 1024)."#
        }
        Capability::CAP_NET_BROADCAST => {
            r#"(Unused) Make socket broadcasts, and listen to multicasts."#
        }
        Capability::CAP_NET_RAW => {
            r#"• Use RAW and PACKET sockets;
 • bind to any address for transparent proxying."#
        }
        Capability::CAP_PERFMON => {
            r#"(since Linux 5.8)
 Employ various performance-monitoring mechanisms, including:

 • call perf_event_open(2);
 • employ various BPF operations that have performance implications.

 This capability was added in Linux 5.8 to separate out performance monitoring functionality from the
 overloaded CAP_SYS_ADMIN capability. See also the kernel source file
 Documentation/admin-guide/perf-security.rst."#
        }
        Capability::CAP_SETGID => {
            r#"• Make arbitrary manipulations of process GIDs and supplementary GID list;
 • forge GID when passing socket credentials via UNIX domain sockets;
 • write a group ID mapping in a user namespace (see user_namespaces(7))."#
        }
        Capability::CAP_SETFCAP => {
            r#"(since Linux 2.6.24)
 Set arbitrary capabilities on a file.

 Since Linux 5.12, this capability is also needed to map user ID 0 in a new user namespace; see
 user_namespaces(7) for details."#
        }
        Capability::CAP_SETPCAP => {
            r#"If file capabilities are supported (i.e., since Linux 2.6.24): add any capability from the calling
 thread's bounding set to its inheritable set; drop capabilities from the bounding set (via prctl(2)
 PR_CAPBSET_DROP); make changes to the securebits flags.

 If file capabilities are not supported (i.e., before Linux 2.6.24): grant or remove any capability in
 the caller's permitted capability set to or from any other process. (This property of CAP_SETPCAP is
 not available when the kernel is configured to support file capabilities, since CAP_SETPCAP has entirely
 different semantics for such kernels.)"#
        }
        Capability::CAP_SETUID => {
            r#"• Make arbitrary manipulations of process UIDs (setuid(2), setreuid(2), setresuid(2), setfsuid(2));
 • forge UID when passing socket credentials via UNIX domain sockets;
 • write a user ID mapping in a user namespace (see user_namespaces(7))."#
        }
        Capability::CAP_SYS_ADMIN => {
            r#"Note: this capability is overloaded; see Notes to kernel developers below.

 • Perform a range of system administration operations including: quotactl(2), mount(2), umount(2),
 pivot_root(2), swapon(2), swapoff(2), sethostname(2), and setdomainname(2);
 • perform privileged syslog(2) operations (since Linux 2.6.37, CAP_SYSLOG should be used to permit such
 operations);
 • perform VM86_REQUEST_IRQ vm86(2) command;
 • access the same checkpoint/restore functionality that is governed by CAP_CHECKPOINT_RESTORE (but the
 latter, weaker capability is preferred for accessing that functionality).
 • perform the same BPF operations as are governed by CAP_BPF (but the latter, weaker capability is
 preferred for accessing that functionality).
 • employ the same performance monitoring mechanisms as are governed by CAP_PERFMON (but the latter,
 weaker capability is preferred for accessing that functionality).
 • perform IPC_SET and IPC_RMID operations on arbitrary System V IPC objects;
 • override RLIMIT_NPROC resource limit;
 • perform operations on trusted and security extended attributes (see xattr(7));
 • use lookup_dcookie(2);
 • use ioprio_set(2) to assign IOPRIO_CLASS_RT and (before Linux 2.6.25) IOPRIO_CLASS_IDLE I/O
 scheduling classes;
 • forge PID when passing socket credentials via UNIX domain sockets;
 • exceed /proc/sys/fs/file-max, the system-wide limit on the number of open files, in system calls that
 open files (e.g., accept(2), execve(2), open(2), pipe(2));
 • employ CLONE_* flags that create new namespaces with clone(2) and unshare(2) (but, since Linux 3.8,
 creating user namespaces does not require any capability);
 • access privileged perf event information;
 • call setns(2) (requires CAP_SYS_ADMIN in the target namespace);
 • call fanotify_init(2);
 • perform privileged KEYCTL_CHOWN and KEYCTL_SETPERM keyctl(2) operations;
 • perform madvise(2) MADV_HWPOISON operation;
 • employ the TIOCSTI ioctl(2) to insert characters into the input queue of a terminal other than the
 caller's controlling terminal;
 • employ the obsolete nfsservctl(2) system call;
 • employ the obsolete bdflush(2) system call;
 • perform various privileged block-device ioctl(2) operations;
 • perform various privileged filesystem ioctl(2) operations;
 • perform privileged ioctl(2) operations on the /dev/random device (see random(4));
 • install a seccomp(2) filter without first having to set the no_new_privs thread attribute;
 • modify allow/deny rules for device control groups;
 • employ the ptrace(2) PTRACE_SECCOMP_GET_FILTER operation to dump tracee's seccomp filters;
 • employ the ptrace(2) PTRACE_SETOPTIONS operation to suspend the tracee's seccomp protections (i.e.,
 the PTRACE_O_SUSPEND_SECCOMP flag);
 • perform administrative operations on many device drivers;
 • modify autogroup nice values by writing to /proc/pid/autogroup (see sched(7))."#
        }
        Capability::CAP_SYS_BOOT => r#"Use reboot(2) and kexec_load(2)."#,
        Capability::CAP_SYS_CHROOT => {
            r#"• Use chroot(2);
 • change mount namespaces using setns(2)."#
        }
        Capability::CAP_SYS_MODULE => {
            r#"• Load and unload kernel modules (see init_module(2) and delete_module(2));
 • before Linux 2.6.25: drop capabilities from the system-wide capability bounding set."#
        }
        Capability::CAP_SYS_NICE => {
            r#"• Lower the process nice value (nice(2), setpriority(2)) and change the nice value for arbitrary
 processes;
 • set real-time scheduling policies for calling process, and set scheduling policies and priorities for
 arbitrary processes (sched_setscheduler(2), sched_setparam(2), sched_setattr(2));
 • set CPU affinity for arbitrary processes (sched_setaffinity(2));
 • set I/O scheduling class and priority for arbitrary processes (ioprio_set(2));
 • apply migrate_pages(2) to arbitrary processes and allow processes to be migrated to arbitrary nodes;
 • apply move_pages(2) to arbitrary processes;
 • use the MPOL_MF_MOVE_ALL flag with mbind(2) and move_pages(2)."#
        }
        Capability::CAP_SYS_PACCT => r#"Use acct(2)."#,
        Capability::CAP_SYS_PTRACE => {
            r#"• Trace arbitrary processes using ptrace(2);
 • apply get_robust_list(2) to arbitrary processes;
 • transfer data to or from the memory of arbitrary processes using process_vm_readv(2) and
 process_vm_writev(2);
 • inspect processes using kcmp(2)."#
        }
        Capability::CAP_SYS_RAWIO => {
            r#"• Perform I/O port operations (iopl(2) and ioperm(2));
 • access /proc/kcore;
 • employ the FIBMAP ioctl(2) operation;
 • open devices for accessing x86 model-specific registers (MSRs, see msr(4));
 • update /proc/sys/vm/mmap_min_addr;
 • create memory mappings at addresses below the value specified by /proc/sys/vm/mmap_min_addr;
 • map files in /proc/bus/pci;
 • open /dev/mem and /dev/kmem;
 • perform various SCSI device commands;
 • perform certain operations on hpsa(4) and cciss(4) devices;
 • perform a range of device-specific operations on other devices."#
        }
        Capability::CAP_SYS_RESOURCE => {
            r#"• Use reserved space on ext2 filesystems;
 • make ioctl(2) calls controlling ext3 journaling;
 • override disk quota limits;
 • increase resource limits (see setrlimit(2));
 • override RLIMIT_NPROC resource limit;
 • override maximum number of consoles on console allocation;
 • override maximum number of keymaps;
 • allow more than 64hz interrupts from the real-time clock;
 • raise msg_qbytes limit for a System V message queue above the limit in /proc/sys/kernel/msgmnb (see
 msgop(2) and msgctl(2));
 • allow the RLIMIT_NOFILE resource limit on the number of "in-flight" file descriptors to be bypassed
 when passing file descriptors to another process via a UNIX domain socket (see unix(7));
 • override the /proc/sys/fs/pipe-size-max limit when setting the capacity of a pipe using the
 F_SETPIPE_SZ fcntl(2) command;
 • use F_SETPIPE_SZ to increase the capacity of a pipe above the limit specified by
 /proc/sys/fs/pipe-max-size;
 • override /proc/sys/fs/mqueue/queues_max, /proc/sys/fs/mqueue/msg_max, and
 /proc/sys/fs/mqueue/msgsize_max limits when creating POSIX message queues (see mq_overview(7));
 • employ the prctl(2) PR_SET_MM operation;
 • set /proc/pid/oom_score_adj to a value lower than the value last set by a process with
 CAP_SYS_RESOURCE."#
        }
        Capability::CAP_SYS_TIME => {
            r#"Set system clock (settimeofday(2), stime(2), adjtimex(2)); set real-time (hardware) clock."#
        }
        Capability::CAP_SYS_TTY_CONFIG => {
            r#"Use vhangup(2); employ various privileged ioctl(2) operations on virtual terminals."#
        }
        Capability::CAP_SYSLOG => {
            r#"(since Linux 2.6.37)
 • Perform privileged syslog(2) operations. See syslog(2) for information on which operations require
 privilege.
 • View kernel addresses exposed via /proc and other interfaces when /proc/sys/kernel/kptr_restrict has
 the value 1. (See the discussion of the kptr_restrict in proc(5).)"#
        }
        Capability::CAP_WAKE_ALARM => {
            r#"(since Linux 3.0)
 Trigger something that will wake up the system (set CLOCK_REALTIME_ALARM and CLOCK_BOOTTIME_ALARM
 timers)."#
        }
        Capability::__Nonexhaustive => unreachable!("invalid capability"),
    }
}
